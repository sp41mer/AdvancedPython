# [[7,5],[5,2],[5,1],[6,3],[6,2],[7,6],[3,4],[3,2],[3,0],[1,0],[2,0],[4,0]]
# [[V1, V2], [V1, V2], [V1, V2]]

# Задаем количество уроков/дисциплин которое надо изучить
from collections import defaultdict, deque

num_lessons = 8
# Задаем входную последовательность
deps = [[7,5],[5,2],[5,1],[6,3],[6,2],[7,6],[3,4],[3,2],[3,0],[1,0],[2,0],[4,0]]
# Инициализация структуры данных для графа (словарь)
graph = defaultdict(list)
# Инициалазция структуры данных для хранения входящих ребер (список)
incoming_edges = [0 for i in range(num_lessons)]
# Заполняем граф:
# Проходимся по входной последовательности и берем новую зависимость:
for lesson in deps:
#       В графе в список V1 добавляем V2
        graph[lesson[0]].append(lesson[1])
#       В кол-ве входящих ребер добавляем единицу к V2
        incoming_edges[lesson[1]] += 1
# Инициализация с.д. для вершин кандидатов
cand = deque()
# Проходимся по массиву входящих ребер и выписываем в в с.д. вершины, где 0 вх. ребер (enumerate)
for node, number_of_edges in enumerate(incoming_edges):
    if number_of_edges == 0:
        cand.append(node)
# Заводим с.д. для хранения итоговой последовательности
answer = []
# Пока у нас есть кандидаты:
while cand:
    # Берем любого/первого/последнего кандидата (К1)
    current_element = cand.pop()
    # Для всех вершин в которые можно попасть из кандидата уменьшаем число входных ребер
    for node in graph[current_element]:
        incoming_edges[node] -= 1
        # Если число входных ребер стало = 0, то добавляем в список кандидатов
        if incoming_edges[node] == 0:
            cand.append(node)
    # Добавляем кандидата К1 в итоговую последовательность
    answer.append(current_element)
# Выводим на печать результат
print(answer)

# 1. Попробовать использовать стек вместо очереди
# 2. Переписать начало кода (заполнение графа) без использование defaultdict
# 3. Придумать каким образом мы можем проверять возможно ли решение вообще